<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotLiquid</name>
    </assembly>
    <members>
        <member name="T:DotLiquid.FileSystems.EmbeddedFileSystem">
            <summary>
            This implements a file system which retrieves template files from embedded resources in .NET assemblies.
            
            Its behavior is the same as with the Local File System, except this uses namespaces and embedded resources
            instead of directories and files.
            
            Example:
            
            var fileSystem = new EmbeddedFileSystem("My.Base.Namespace");
            
            fileSystem.FullPath("mypartial") # => "My.Base.Namespace._mypartial.liquid"
            fileSystem.FullPath("dir/mypartial") # => "My.Base.Namespace.dir._mypartial.liquid"
            </summary>
        </member>
        <member name="T:DotLiquid.FileSystems.IFileSystem">
            <summary>
            A Liquid file system is way to let your templates retrieve other templates for use with the include tag.
            
            You can implement subclasses that retrieve templates from the database, from the file system using a different
            path structure, you can provide them as hard-coded inline strings, or any manner that you see fit.
            
            You can add additional instance variables, arguments, or methods as needed.
            
            Example:
            
            Liquid::Template.file_system = Liquid::LocalFileSystem.new(template_path)
            liquid = Liquid::Template.parse(template)
            
            This will parse the template with a LocalFileSystem implementation rooted at 'template_path'.
            </summary>
        </member>
        <member name="M:DotLiquid.FileSystems.IFileSystem.ReadTemplateFile(DotLiquid.Context,System.String)">
            <summary>
            Called by Liquid to retrieve a template file
            It can return a Template instance or string contents
            </summary>
            <param name="templatePath"></param>
            <returns></returns>
        </member>
        <member name="T:DotLiquid.FileSystems.LocalFileSystem">
            <summary>
            This implements an abstract file system which retrieves template files named in a manner similar to Rails partials,
            ie. with the template name prefixed with an underscore. The extension ".liquid" is also added.
            
            For security reasons, template paths are only allowed to contain letters, numbers, and underscore.
            
            Example:
            
            file_system = Liquid::LocalFileSystem.new("/some/path")
            
            file_system.full_path("mypartial") # => "/some/path/_mypartial.liquid"
            file_system.full_path("dir/mypartial") # => "/some/path/dir/_mypartial.liquid"
            </summary>
        </member>
        <member name="T:DotLiquid.LiquidTypeAttribute">
            <summary>
            Specifies the type is safe to be rendered by DotLiquid.
            </summary>
        </member>
        <member name="P:DotLiquid.LiquidTypeAttribute.AllowedMembers">
            <summary>
            An array of property and method names that are allowed to be called on the object.
            </summary>
        </member>
        <member name="M:DotLiquid.LiquidTypeAttribute.#ctor(System.String[])">
            <summary>
            
            </summary>
            <param name="allowedMembers">An array of property and method names that are allowed to be called on the object.</param>
        </member>
        <member name="P:DotLiquid.RenderParameters.Context">
            <summary>
            If you provide a Context object, you do not need to set any other parameters.
            </summary>
        </member>
        <member name="P:DotLiquid.RenderParameters.RethrowErrors">
            <summary>
            Gets or sets a value that controls whether errors are thrown as exceptions.
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.Raw">
            <summary>
            Raw
            Raw outputs text as is, usefull if your template contains Liquid syntax.
            
            {% raw %}{% if user = 'tobi' %}hi{% endif %}{% endraw %}
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.Assign">
             <summary>
             Assign sets a variable in your template.
            
             {% assign foo = 'monkey' %}
            
             You can then use the variable later in the page.
            
             {{ foo }}
             </summary>
        </member>
        <member name="T:DotLiquid.Tags.Capture">
            <summary>
            Capture stores the result of a block into a variable without rendering it inplace.
            
            {% capture heading %}
            Monkeys!
            {% endcapture %}
            ...
            <h1>{{ heading }}</h1>
            
            Capture is useful for saving content for use later in your template, such as
            in a sidebar or footer.
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.Block">
            <summary>
            The Block tag is used in conjunction with the Extends tag to provide template inheritance.
            For an example please refer to the Extends tag.
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.Extends">
             <summary>
             The Extends tag is used in conjunction with the Block tag to provide template inheritance.
             For further syntax and usage please refer to
             <see cref="!:http://docs.djangoproject.com/en/dev/topics/templates/#template-inheritance"/>
             </summary>
             <example>
            	To see how Extends and Block can be used together, start by considering this example:
            
             <html>
             <head>
               <title>{% block title %}My Website{% endblock %}</title>
             </head>
            
             <body>
               <div id="sidebar">
                 {% block sidebar %}
                 <ul>
                   <li><a href="/">Home</a></li>
                   <li><a href="/blog/">Blog</a></li>
                 </ul>
                 {% endblock %}
               </div>
            
               <div id="content">
                 {% block content %}{% endblock %}
               </div>
             </body>
             </html>
            
             We'll assume this is saved in a file called base.html. In ASP.NET MVC terminology, this file would
             be the master page or layout, and each of the "blocks" would be a section. Child templates
             (in ASP.NET MVC terminology, views) fill or override these blocks with content. If a child template
             does not define a particular block, then the content from the parent template is used as a fallback.
            
             A child template might look like this:
            
             {% extends "base.html" %}
             {% block title %}My AMAZING Website{% endblock %}
            
             {% block content %}
             {% for entry in blog_entries %}
               <h2>{{ entry.title }}</h2>
               <p>{{ entry.body }}</p>
             {% endfor %}
             {% endblock %}
            
             The current IFileSystem will be used to locate "base.html".
             </example>
        </member>
        <member name="T:DotLiquid.Tags.Literal">
            <summary>
            Literal
            Literal outputs text as is, usefull if your template contains Liquid syntax.
            
            {% literal %}{% if user = 'tobi' %}hi{% endif %}{% endliteral %}
            
            or (shorthand version)
            
            {{{ {% if user = 'tobi' %}hi{% endif %} }}}
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.Unless">
            <summary>
            Unless is a conditional just like 'if' but works on the inverse logic.
            
             {% unless x &lt; 0 %} x is greater than zero {% end %}
            </summary>
        </member>
        <member name="T:DotLiquid.Tags.If">
             <summary>
             If is the conditional block
            
             {% if user.admin %}
               Admin user!
             {% else %}
               Not admin user
             {% endif %}
            
              There are {% if count &lt; 5 %} less {% else %} more {% endif %} items than you need.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:DotLiquid.Tags.For" -->
        <member name="T:DotLiquid.Tags.Cycle">
            <summary>
            Cycle is usually used within a loop to alternate between values, like colors or DOM classes.
            
              {% for item in items %}
               <div class="{% cycle 'red', 'green', 'blue' %}"> {{ item }} </div>
              {% end %}
            
               <div class="red"> Item one </div>
               <div class="green"> Item two </div>
               <div class="blue"> Item three </div>
               <div class="red"> Item four </div>
               <div class="green"> Item five</div>
            </summary>
        </member>
        <member name="T:DotLiquid.Util.ExpressionUtility">
            <summary>
            Some of this code was taken from http://www.yoda.arachsys.com/csharp/miscutil/usage/genericoperators.html.
            General purpose Expression utilities
            </summary>
        </member>
        <member name="M:DotLiquid.Util.ExpressionUtility.CreateExpression(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression},System.Type,System.Type,System.Type,System.Boolean)">
            <summary>
            Create a function delegate representing a binary operation
            </summary>
            <param name="body">Body factory</param>
            <param name="leftType"></param>
            <param name="rightType"></param>
            <param name="resultType"></param>
            <param name="castArgsToResultOnFailure">
            If no matching operation is possible, attempt to convert
            TArg1 and TArg2 to TResult for a match? For example, there is no
            "decimal operator /(decimal, int)", but by converting TArg2 (int) to
            TResult (decimal) a match is found.
            </param>
            <returns>Compiled function delegate</returns>
        </member>
        <member name="M:DotLiquid.Util.ListExtensionMethods.Shift``1(System.Collections.Generic.List{``0})">
            <summary>
            Removes the first element from the list and returns it,
            or null if the list is empty.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Util.ListExtensionMethods.Pop``1(System.Collections.Generic.List{``0})">
            <summary>
            Removes the last element from the list and returns it,
            or null if the list is empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:DotLiquid.Util.Range">
            <summary>
            Taken from code at http://www.pluralsight-training.net/community/blogs/dbox/archive/2005/04/24/7690.aspx.
            </summary>
        </member>
        <member name="M:DotLiquid.Util.R.Scan(System.String,System.String,System.Action{System.String,System.String})">
            <summary>
            Overload that only works when the pattern contains two groups. The callback
            is called for each match, passing the two group values.
            </summary>
            <param name="input"></param>
            <param name="pattern"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="T:DotLiquid.Condition">
             <summary>
             Container for liquid nodes which conveniently wraps decision making logic
            
             Example:
            
             c = Condition.new('1', '==', '1')
             c.evaluate #=> true
             </summary>
        </member>
        <member name="M:DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Adds filters to this context.
            this does not register the filters with the main Template object. see <tt>Template.register_filter</tt>
            for that
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:DotLiquid.Context.Push(DotLiquid.Hash)">
            <summary>
            Push new local scope on the stack. use <tt>Context#stack</tt> instead
            </summary>
            <param name="newScope"></param>
        </member>
        <member name="M:DotLiquid.Context.Merge(DotLiquid.Hash)">
            <summary>
            Merge a hash of variables in the current local scope
            </summary>
            <param name="newScopes"></param>
        </member>
        <member name="M:DotLiquid.Context.Pop">
            <summary>
            Pop from the stack. use <tt>Context#stack</tt> instead
            </summary>
        </member>
        <member name="M:DotLiquid.Context.Stack(DotLiquid.Hash,System.Action)">
             <summary>
             pushes a new local scope on the stack, pops it at the end of the block
            
             Example:
            
             context.stack do
             context['var'] = 'hi'
             end
             context['var] #=> nil
             </summary>
             <param name="newScope"></param>
             <param name="callback"></param>
             <returns></returns>
        </member>
        <member name="P:DotLiquid.Context.Item(System.String)">
            <summary>
            Only allow String, Numeric, Hash, Array, Proc, Boolean or <tt>Liquid::Drop</tt>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Context.Resolve(System.String)">
             <summary>
             Look up variable, either resolve directly after considering the name. We can directly handle
             Strings, digits, floats and booleans (true,false). If no match is made we lookup the variable in the current scope and
             later move up to the parent blocks to see if we can resolve the variable somewhere up the tree.
             Some special keywords return symbols. Those symbols are to be called on the rhs object in expressions
            
             Example:
            
             products == empty #=> products.empty?
             </summary>
             <param name="key"></param>
             <returns></returns>
        </member>
        <member name="M:DotLiquid.Context.FindVariable(System.String)">
            <summary>
            Fetches an object starting at the local scope and then moving up
            the hierarchy
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Context.Variable(System.String)">
             <summary>
             Resolves namespaced queries gracefully.
            
             Example
            
             @context['hash'] = {"name" => 'tobi'}
             assert_equal 'tobi', @context['hash.name']
             assert_equal 'tobi', @context['hash["name"]']
             </summary>
             <param name="markup"></param>
             <returns></returns>
        </member>
        <member name="M:DotLiquid.Document.Initialize(System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            We don't need markup to open this block
            </summary>
            <param name="tagName"></param>
            <param name="markup"></param>
            <param name="tokens"></param>
        </member>
        <member name="P:DotLiquid.Document.BlockDelimiter">
            <summary>
            There isn't a real delimiter
            </summary>
        </member>
        <member name="M:DotLiquid.Document.AssertMissingDelimitation">
            <summary>
            Document blocks don't need to be terminated since they are not actually opened
            </summary>
        </member>
        <member name="T:DotLiquid.TypeResolution">
            <summary>
            Configurable typing metadata collection
            </summary>
        </member>
        <member name="T:DotLiquid.DropBase">
             <summary>
             A drop in liquid is a class which allows you to to export DOM like things to liquid
             Methods of drops are callable.
             The main use for liquid drops is the implement lazy loaded objects.
             If you would like to make data available to the web designers which you don't want loaded unless needed then
             a drop is a great way to do that
            
             Example:
            
             class ProductDrop &lt; Liquid::Drop
             def top_sales
             Shop.current.products.find(:all, :order => 'sales', :limit => 10 )
             end
             end
            
             tmpl = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {%endfor%} ' )
             tmpl.render('product' => ProductDrop.new ) # will invoke top_sales query.
            
             Your drop can either implement the methods sans any parameters or implement the before_method(name) method which is a
             catch all
             </summary>
        </member>
        <member name="P:DotLiquid.DropBase.Item(System.Object)">
            <summary>
            Just an alias for InvokeDrop - but the presence of the indexer
            means that Liquid will access Drop objects as though they are
            dictionaries or hashes.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.DropBase.BeforeMethod(System.String)">
            <summary>
            Catch all for the method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.DropBase.InvokeDrop(System.Object)">
            <summary>
            Called by liquid to invoke a drop
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:DotLiquid.DropProxy">
            <summary>
            Proxy for types not derived from DropBase
            </summary>
        </member>
        <member name="M:DotLiquid.DropProxy.#ctor(System.Object,System.String[])">
            <summary>
            Create a new DropProxy object
            </summary>
            <param name="obj">The object to create a proxy for</param>
            <param name="allowedMembers">An array of property and method names that are allowed to be called on the object.</param>
        </member>
        <member name="T:DotLiquid.ILiquidizable">
            <summary>
            See here for motivation: <see cref="!:http://wiki.github.com/tobi/liquid/using-liquid-without-rails"/>.
            This allows for extra security by only giving the template access to the specific
            variables you want it to have access to.
            </summary>
        </member>
        <member name="T:DotLiquid.NamingConventions.RubyNamingConvention">
            <summary>
            Converts C# member names to Ruby-style names for access by Liquid templates.
            </summary>
            <example>
            Input: Text
            Output: text
            
            Input: ScopesAsArray
            Output: scopes_as_array
            </example>
        </member>
        <member name="T:DotLiquid.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.AssignTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;assign&apos; tag - Valid syntax: assign [var] = [source].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlankFileSystemDoesNotAllowIncludesException">
            <summary>
              Looks up a localized string similar to Error - This liquid context does not allow includes.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagAlreadyDefinedException">
            <summary>
              Looks up a localized string similar to Liquid Error - Block &apos;{0}&apos; already defined.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagNoElseException">
            <summary>
              Looks up a localized string similar to {0} tag does not expect else tag.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagNoEndException">
            <summary>
              Looks up a localized string similar to &apos;end&apos; is not a valid delimiter for {0} tags. Use {1}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagNotClosedException">
            <summary>
              Looks up a localized string similar to {0} tag was never closed.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagNotTerminatedException">
            <summary>
              Looks up a localized string similar to Tag &apos;{0}&apos; was not properly terminated with regexp: {1}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;block&apos; tag - Valid syntax: block [name].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockUnknownTagException">
            <summary>
              Looks up a localized string similar to Unknown tag &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.BlockVariableNotTerminatedException">
            <summary>
              Looks up a localized string similar to Variable &apos;{0}&apos; was not properly terminated with regexp: {1}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.CaptureTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;capture&apos; tag - Valid syntax: capture [var].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.CaseTagElseSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;case&apos; tag - Valid else condition: {{% else %}} (no parameters).
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.CaseTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;case&apos; tag - Valid syntax: case [condition].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.CaseTagWhenSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;case&apos; tag - Valid when condition: {{% when [condition] [or condition2...] %}}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ConditionUnknownOperatorException">
            <summary>
              Looks up a localized string similar to Unknown operator {0}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ContextLiquidError">
            <summary>
              Looks up a localized string similar to Liquid error: {0}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ContextLiquidSyntaxError">
            <summary>
              Looks up a localized string similar to Liquid syntax error: {0}.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ContextObjectInvalidException">
            <summary>
              Looks up a localized string similar to Object &apos;{0}&apos; is invalid because it is neither a built-in type nor implements ILiquidizable.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ContextStackException">
            <summary>
              Looks up a localized string similar to Nesting too deep.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.CycleTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;cycle&apos; tag - Valid syntax: cycle [name :] var [, var2, var3 ...].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.DropWrongNamingConventionMessage">
            <summary>
              Looks up a localized string similar to Missing property. Did you mean &apos;{0}&apos;?.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ExtendsTagCanBeUsedOneException">
            <summary>
              Looks up a localized string similar to Liquid Error - &apos;extends&apos; tag can be used only once.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ExtendsTagMustBeFirstTagException">
            <summary>
              Looks up a localized string similar to Liquid Error - &apos;extends&apos; must be the first tag in an extending template.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ExtendsTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;extends&apos; tag - Valid syntax: extends [template].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ExtendsTagUnallowedTagsException">
            <summary>
              Looks up a localized string similar to Liquid Error - Only &apos;comment&apos; and &apos;block&apos; tags are allowed in an extending template.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.ForTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;for&apos; tag - Valid syntax: for [item] in [collection].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.IfTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;if&apos; tag - Valid syntax: if [expression].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.IncludeTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;include&apos; tag - Valid syntax: include [template].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.LocalFileSystemIllegalTemplateNameException">
            <summary>
              Looks up a localized string similar to Error - Illegal template name &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.LocalFileSystemIllegalTemplatePathException">
            <summary>
              Looks up a localized string similar to Error - Illegal template path &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.LocalFileSystemTemplateNotFoundException">
            <summary>
              Looks up a localized string similar to Error - No such template &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.StrainerFilterHasNoValueException">
            <summary>
              Looks up a localized string similar to Error - Filter &apos;{0}&apos; does not have a default value for &apos;{1}&apos; and no value was supplied.
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.TableRowTagSyntaxException">
            <summary>
              Looks up a localized string similar to Syntax Error in &apos;tablerow&apos; tag - Valid syntax: tablerow [item] in [collection] cols=[number].
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.VariableFilterNotFoundException">
            <summary>
              Looks up a localized string similar to Error - Filter &apos;{0}&apos; in &apos;{1}&apos; could not be found..
            </summary>
        </member>
        <member name="P:DotLiquid.Properties.Resources.WeakTableKeyNotFoundException">
            <summary>
              Looks up a localized string similar to key could not be found.
            </summary>
        </member>
        <member name="M:DotLiquid.StandardFilters.Size(System.Object)">
            <summary>
            Return the size of an array or of an string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Slice(System.String,System.Int32,System.Int32)">
            <summary>
            Return a Part of a String
            </summary>
            <param name="input"></param>
            <param name="start"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Downcase(System.String)">
            <summary>
            convert a input string to DOWNCASE
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Upcase(System.String)">
            <summary>
            convert a input string to UPCASE
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Capitalize(System.String)">
            <summary>
            capitalize words in the input sentence
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Truncate(System.String,System.Int32,System.String)">
            <summary>
            Truncates a string down to x characters
            </summary>
            <param name="input"></param>
            <param name="length"></param>
            <param name="truncateString"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Split(System.String,System.String)">
            <summary>
            Split input string into an array of substrings separated by given pattern.
            </summary>
            <param name="input"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.StripNewlines(System.String)">
            <summary>
            Remove all newlines from the string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Join(System.Collections.IEnumerable,System.String)">
            <summary>
            Join elements of the array with a certain character between them
            </summary>
            <param name="input"></param>
            <param name="glue"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Sort(System.Object,System.String)">
            <summary>
            Sort elements of the array
            provide optional property with which to sort an array of hashes or drops
            </summary>
            <param name="input"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Map(System.Collections.IEnumerable,System.String)">
            <summary>
            Map/collect on a given property
            </summary>
            <param name="input"></param>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Replace(System.String,System.String,System.String)">
            <summary>
            Replace occurrences of a string with another
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.ReplaceFirst(System.String,System.String,System.String)">
            <summary>
            Replace the first occurence of a string with another
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Remove(System.String,System.String)">
            <summary>
            Remove a substring
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.RemoveFirst(System.String,System.String)">
            <summary>
            Remove the first occurrence of a substring
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Append(System.String,System.String)">
            <summary>
            Add one string to another
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Prepend(System.String,System.String)">
            <summary>
            Prepend a string to another
            </summary>
            <param name="input"></param>
            <param name="string"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.NewlineToBr(System.String)">
            <summary>
            Add <br /> tags in front of all newlines in input string
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Date(System.Object,System.String)">
            <summary>
            Formats a date using a .NET date format string
            </summary>
            <param name="input"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.First(System.Collections.IEnumerable)">
            <summary>
            Get the first element of the passed in array 
            
            Example:
              {{ product.images | first | to_img }}
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Last(System.Collections.IEnumerable)">
            <summary>
            Get the last element of the passed in array 
            
            Example:
              {{ product.images | last | to_img }}
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Plus(System.Object,System.Object)">
            <summary>
            Addition
            </summary>
            <param name="input"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Minus(System.Object,System.Object)">
            <summary>
            Subtraction
            </summary>
            <param name="input"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.Times(System.Object,System.Object)">
            <summary>
            Multiplication
            </summary>
            <param name="input"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.StandardFilters.DividedBy(System.Object,System.Object)">
            <summary>
            Division
            </summary>
            <param name="input"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="T:DotLiquid.Strainer">
            <summary>
            Strainer is the parent class for the filters system.
            New filters are mixed into the strainer class which is then instanciated for each liquid template render run.
            
            One of the strainer's responsibilities is to keep malicious method calls out
            </summary>
        </member>
        <member name="M:DotLiquid.Strainer.Extend(System.Type)">
            <summary>
            In this C# implementation, we can't use mixins. So we grab all the static
            methods from the specified type and use them instead.
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:DotLiquid.Template">
            <summary>
            Templates are central to liquid.
            Interpreting templates is a two step process. First you compile the
            source code you got. During compile time some extensive error checking is performed.
            your code should expect to get some SyntaxErrors.
            
            After you have a compiled template you can then <tt>render</tt> it.
            You can use a compiled template over and over again and keep it cached.
            
            Example:
            
            template = Liquid::Template.parse(source)
            template.render('user_name' => 'bob')
            </summary>
        </member>
        <member name="M:DotLiquid.Template.RegisterFilter(System.Type)">
            <summary>
            Pass a module with filter methods which should be available
             to all liquid views. Good for registering the standard library
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:DotLiquid.Template.RegisterSafeType(System.Type,System.String[])">
            <summary>
            Registers a simple type. DotLiquid will wrap the object in a <see cref="T:DotLiquid.DropProxy"/> object.
            </summary>
            <param name="type">The type to register</param>
            <param name="allowedMembers">An array of property and method names that are allowed to be called on the object.</param>
        </member>
        <member name="M:DotLiquid.Template.RegisterSafeType(System.Type,System.String[],System.Func{System.Object,System.Object})">
            <summary>
            Registers a simple type. DotLiquid will wrap the object in a <see cref="T:DotLiquid.DropProxy"/> object.
            </summary>
            <param name="type">The type to register</param>
            <param name="allowedMembers">An array of property and method names that are allowed to be called on the object.</param>
        </member>
        <member name="M:DotLiquid.Template.RegisterSafeType(System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a simple type using the specified transformer.
            </summary>
            <param name="type">The type to register</param>
            <param name="func">Function that converts the specified type into a Liquid Drop-compatible object (eg, implements ILiquidizable)</param>
        </member>
        <member name="M:DotLiquid.Template.RegisterValueTypeTransformer(System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a simple value type transformer.  Used for rendering a variable to the output stream
            </summary>
            <param name="type">The type to register</param>
            <param name="func">Function that converts the specified type into a Liquid Drop-compatible object (eg, implements ILiquidizable)</param>
        </member>
        <member name="M:DotLiquid.Template.Parse(System.String)">
            <summary>
            Creates a new <tt>Template</tt> object from liquid source code
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Template.#ctor">
            <summary>
            Creates a new <tt>Template</tt> from an array of tokens. Use <tt>Template.parse</tt> instead
            </summary>
        </member>
        <member name="M:DotLiquid.Template.ParseInternal(System.String)">
            <summary>
            Parse source code.
            Returns self for easy chaining
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Template.Render">
            <summary>
            Renders the template using default parameters and returns a string containing the result.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Template.Render(DotLiquid.Hash)">
            <summary>
            Renders the template using the specified local variables and returns a string containing the result.
            </summary>
            <param name="localVariables"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Template.Render(DotLiquid.RenderParameters)">
            <summary>
            Renders the template using the specified parameters and returns a string containing the result.
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Template.Render(System.IO.TextWriter,DotLiquid.RenderParameters)">
            <summary>
            Renders the template into the specified StreamWriter.
            </summary>
            <param name="result"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:DotLiquid.Template.Render(System.IO.Stream,DotLiquid.RenderParameters)">
            <summary>
            Renders the template into the specified Stream.
            </summary>
            <param name="stream"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:DotLiquid.Template.RenderInternal(System.IO.TextWriter,DotLiquid.RenderParameters)">
            <summary>
            Render takes a hash with local variables.
            
            if you use the same filters over and over again consider registering them globally
            with <tt>Template.register_filter</tt>
            
            Following options can be passed:
            
            * <tt>filters</tt> : array with local filters
            * <tt>registers</tt> : hash with register variables. Those can be accessed from
            filters and tags and might be useful to integrate liquid more with its host application
            </summary>
        </member>
        <member name="M:DotLiquid.Template.Tokenize(System.String)">
            <summary>
            Uses the <tt>Liquid::TemplateParser</tt> regexp to tokenize the passed source
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:DotLiquid.Tag.#ctor">
            <summary>
            Only want to allow Tags to be created in inherited classes or tests.
            </summary>
        </member>
        <member name="M:DotLiquid.Tag.Render(DotLiquid.Context)">
            <summary>
            Primarily intended for testing.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:DotLiquid.Variable">
             <summary>
             Holds variables. Variables are only loaded "just in time"
             and are not evaluated as part of the render stage
            
             {{ monkey }}
             {{ user.name }}
            
             Variables can be combined with filters:
            
             {{ user | link }}
             </summary>
        </member>
        <member name="M:DotLiquid.Variable.Render(DotLiquid.Context)">
            <summary>
            Primarily intended for testing.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:System.FastReflection.StructTuple`2">
            <summary>
            Struct type tuple
            </summary>
        </member>
        <member name="T:System.FastReflection.MethodInvoker">
            <summary>
            Delegate use to invoke any method
            </summary>
        </member>
        <member name="T:System.FastReflection.MemberGetter">
            <summary>
            Delegate use to set get property or field
            </summary>
        </member>
        <member name="T:System.FastReflection.MemberSetter">
            <summary>
            Delegate use to set any property or field
            </summary>
        </member>
        <member name="T:System.FastReflection.ReflectionExtensions">
            <summary>
            Extension methods for reflection
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.MakeInvoker(System.Reflection.MethodInfo)">
            <summary>
            Create dynamic delegate from method info
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.MakeSetter(System.Reflection.MemberInfo)">
            <summary>
            Create setter delegate from member info, support property and field
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.MakeGetter(System.Reflection.MemberInfo)">
            <summary>
            Create setter delegate from member info, support property and field
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastInvoke(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Same as MethodInfo.Invoke, but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastSetValue(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
            Same as PropertyInfo.SetValue or FieldInfo.SetValue, but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Same as PropertyInfo.GetValue or FieldInfo.GetValue, but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetProperties(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetProperties(bindFlags), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetProperties(System.Type)">
            <summary>
            Same as Type.GetProperties(), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetFields(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetFields(bindFlags), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetFields(System.Type)">
            <summary>
            Same as Type.GetFields(), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetMethods(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetMethods(bindingFlags), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetMethods(System.Type)">
            <summary>
            Same as Type.GetMethods(), but work faster
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetProperty(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetProperty(name, bindFlags)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetProperty(System.Type,System.String)">
            <summary>
            Same as Type.GetProperty(name)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetField(name, bindFlags)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetField(System.Type,System.String)">
            <summary>
            Same as Type.GetField(name)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetMethod(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Same as Type.GetMethod(name, bindFlags)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
        <member name="M:System.FastReflection.ReflectionExtensions.FastGetMethod(System.Type,System.String)">
            <summary>
            Same as Type.GetMethod(name)
            Original implemenation is enough fast, here just call the original method
            </summary>
        </member>
    </members>
</doc>
